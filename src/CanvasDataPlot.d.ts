import * as d3 from 'd3';
import * as d3Axis from 'd3-axis';
export declare class CanvasDataPlot {
    parent: d3.Selection<any, {}, HTMLElement, {}>;
    canvasDimensions: Array<number>;
    config: CanvasDataPlot.Config;
    data: Array<Array<[Date, number]>>;
    dataIDs: Array<string>;
    dataLabels: Array<string>;
    displayIndexStart: Array<number>;
    displayIndexEnd: Array<number>;
    dataColors: Array<string>;
    xAxisLabelText: string;
    yAxisLabelText: string;
    updateViewCallback: undefined;
    disableLegend: boolean;
    invertYAxis: boolean;
    gridColor: string;
    markerLineWidth: number;
    markerRadius: number;
    xTicksPerPixel: number;
    yTicksPerPixel: number;
    minCanvasWidth: number;
    minCanvasHeight: number;
    legendMargin: number;
    legendXPadding: number;
    legendYPadding: number;
    legendLineHeight: number;
    margin: CanvasDataPlot.PlotMargins;
    showToolstips: boolean;
    tooltipRadiusSquared: number;
    totalWidth: number;
    totalHeight: number;
    width: number;
    legendWidth: number;
    height: number;
    zoomListener: any;
    div: d3.Selection<any, {}, any, {}>;
    d3Canvas: d3.Selection<any, {}, any, {}>;
    canvas: CanvasRenderingContext2D;
    svg: d3.Selection<any, {}, any, {}>;
    svgTranslateGroup: d3.Selection<any, {}, any, {}>;
    xScale: d3Axis.AxisScale<any>;
    yScale: d3Axis.AxisScale<number>;
    xAxis: d3Axis.Axis<d3Axis.AxisDomain>;
    yAxis: d3Axis.Axis<d3Axis.AxisDomain>;
    xAxisLabel: d3.Selection<SVGTextElement, {}, any, {}>;
    yAxisLabel: d3.Selection<SVGTextElement, {}, any, {}>;
    yAxisGroup: d3.Selection<any, {}, any, {}>;
    xAxisGroup: d3.Selection<any, {}, any, {}>;
    tooltip: d3.Selection<any, {}, any, {}>;
    legend: d3.Selection<any, {}, any, {}>;
    legendBG: any;
    showTooltips: boolean;
    xAxisZoom: boolean;
    yAxisZoom: boolean;
    constructor(parentElement: d3.Selection<any, {}, HTMLElement, {}>, canvasDimensions: Array<number>, config?: CanvasDataPlot.Config);
    zoomFunction(): void;
    addDataSet(uniqueID?: string, label?: string, dataSet?: Array<[Date, number]>, colorString?: string, updateDomains?: boolean, copyData?: boolean): void;
    addDataPoint(uniqueID?: string, dataPoint?: [Date, number], updateDomains?: boolean, copyData?: boolean): void;
    removeDataSet(uniqueID: string): void;
    setZoomXAxis(zoomX: boolean): void;
    setZoomYAxis(zoomY: boolean): void;
    resize(dimensions: Array<number>): void;
    updateDomains(xDomain: Array<Date>, yDomain: Array<number>, makeItNice: boolean): void;
    getXDomain(): Array<Date>;
    getYDomain(): Array<number>;
    calculateXDomain(): any;
    calculateYDomain(): any;
    destroy(): void;
    setupXScaleAndAxis(): void;
    setupYScaleAndAxis(): void;
    getDataID(index: number): string;
    updateTooltip(): void;
    getTooltipStringX(dataPoint: [Date, number]): string;
    getTooltipStringY(dataPoint: [Date, number]): string;
    showTooltip(position: Array<number>, color: string, xText: string, yText: string): void;
    removeTooltip(): void;
    updateLegend(): void;
    findLargestSmaller(d: Array<[Date, number]>, ia: number, ib: number, v: number): number;
    updateDisplayIndices(): void;
    redrawCanvasAndAxes(): void;
    drawCanvas(): void;
    drawGrid(): void;
    convertRange(value: any, r1: Array<number>, r2: Array<number>): number;
    drawDataSet(dataIndex: number): void;
    resetZoomListenerAxes(): void;
    updateZoomValues(scale: number, translate: number): void;
    CanvasPlot_shallowObjectCopy(inObj: any): any;
    CanvasPlot_appendToObject(obj: any, objToAppend: any): void;
}
export declare namespace CanvasDataPlot {
    interface Config {
        xAxisLabel?: string;
        yAxisLabel?: string;
        markerLineWidth?: number;
        markerRadius?: number;
        updateViewCallback?: undefined;
        disableLegend?: boolean;
        invertYAxis?: boolean;
        gridColor?: string;
        xTicksPerPixel?: number;
        yTicksPerPixel?: number;
        minCanvasWidth?: number;
        minCanvasHeight?: number;
        legendMargin?: number;
        legendXPadding?: number;
        legendYPadding?: number;
        legendLineHeight?: number;
        plotMargins?: PlotMargins;
        showToolstips?: boolean;
        hasOwnProperty?(prop: string): boolean;
        tooltipRadius?: number;
        plotLineWidth?: number;
        maxInformationDensity?: number;
        showMarkerDensity?: number;
        vectorScale?: number;
        scaleUnits?: string;
        scaleLength?: number;
    }
    interface PlotMargins {
        top?: number;
        right?: number;
        bottom?: number;
        left?: number;
    }
}
